"""

PriceBoard().run() đang làm hai chuyện cùng lúc: 1/ RT Warning cho RMD, 2/ Lưu snapshot bảng điện

"""
import pandas as pd

from request.stock import *


def __formatTicker__(x):
    return x.replace(' ','').replace('*','')

def __formatPrice__(x):
    if not x:  # x == ''
        x = np.nan
    else:
        x = float(x)
    return x

def __formatVolume__(x):
    if not x:  # x == ''
        x = np.nan
    else:
        x = float(x.replace(',',''))*10  # 2,30 -> 2300, 10 -> 100
    return x

def __formatPct__(x):
    if not x:
        x = np.nan
    else:
        x = float(x.replace('%',''))/100
    return x


def __getHTML__(func): # Method decorator

    def wrapper(self,*args,**kwargs):

        currentWarnings = func(self,*args,**kwargs)
        if isfile(join(dirname(__file__),'TempFiles',self.lastWarningFile)):
            # đọc kết quả lần quét cuối cùng
            lastWarnings = pd.read_pickle(self.lastWarningFile)
            mergeTable = pd.merge(
                currentWarnings.reset_index(),
                lastWarnings.reset_index(),
                on=['index','Message'],
                indicator=True,
            )

            repeatWarnings = mergeTable.loc[mergeTable['_merge']=='both',['index','Message']]
            repeatWarningsHTML = repeatWarnings.set_index('index').to_html()
            repeatWarningsHTML = repeatWarningsHTML.replace(
                'border="1"',
                'border="1" style="border-collapse:collapse","border-spacing:0px";',
            )  # remove borders

            newWarnings = mergeTable.loc[mergeTable['_merge']=='left_only',['index','Message']]
            newWarningsHTML = newWarnings.set_index('index').to_html()
            newWarningsHTML = newWarningsHTML.replace(
                'border="1"',
                'border="1" style="border-collapse:collapse","border-spacing:0px","color:red";',
            )  # remove borders, set font color to red

            html_str = f"""
            <html>
                <head></head>
                <body>
                    {newWarningsHTML}
                    {repeatWarningsHTML}
                    <p style="font-family:Times New Roman; font-size:90%"><i>
                        -- Generated by Reporting System
                    </i></p>
                </body>
            </html>
            """

        else:
            newWarningsHTML = currentWarnings.to_html()
            newWarningsHTML = newWarningsHTML.replace(
                'border="1"',
                'border="1" style="border-collapse:collapse","border-spacing:0px","color:red";',
            )  # remove borders, set font color to red

            html_str = f"""
            <html>
                <head></head>
                <body>
                    {newWarningsHTML}
                    <p style="font-family:Times New Roman; font-size:90%"><i>
                        -- Generated by Reporting System
                    </i></p>
                </body>
            </html>
            """

        return html_str
    return wrapper


def __sendMail__(func): # Method decorator

    def wrapper(self,*args,**kwargs):

        now = dt.datetime.now()
        outlook = Dispatch('outlook.application')
        mail = outlook.CreateItem(0)
        mail.To = 'hiepdang@phs.vn'
        # mail.CC = 'hiepdang@phs.vn'
        mail.Subject = f"Market Alert {now.strftime('%H:%M:%S %d.%m.%Y')}"
        table = func(self,*args,**kwargs)
        body = f"""
        <html>
            <head></head>
            <body>
                <p style="font-family:Times New Roman; font-size:110%"><i>
                    {table}
                </i></p>
                <p style="font-family:Times New Roman; font-size:90%"><i>
                    -- Generated by Reporting System
                </i></p>
            </body>
        </html>
        """
        mail.HTMLBody = body
        mail.Send()

    return wrapper


def __retry__(func): # Method decorator
    def wrapper(self,*args,**kwargs):
        n = 0
        while True:
            now = dt.datetime.now()
            func(self,*args,**kwargs) # vẫn quét 1 lần khi chạy ngoài giờ giao dịch
            n += 1
            print('Quét lần: ',n)
            # set các điều kiện break:
            if now.time()>dt.time(15,0,0):
                if isfile(join(dirname(__file__),'TempFiles',self.lastWarningFile)):
                    os.remove(join(dirname(__file__),'TempFiles',self.lastWarningFile))
                break
            if dt.time(11,30,0)<now.time()<dt.time(13,0,0):
                break
            if now.time() < dt.time(9,0,0):
                break

    return wrapper


class PriceBoard:

    PATH = join(dirname(dirname(realpath(__file__))),'dependency','chromedriver')
    ignored_exceptions = (
        ValueError,
        IndexError,
        NoSuchElementException,
        StaleElementReferenceException,
        TimeoutException,
        ElementNotInteractableException
    )

    lastWarningFile = f"{dt.datetime.now().strftime('%Y.%m.%d')}.pickle"

    def __init__(self,exchange):
        if exchange == 'HOSE':
            self.url = 'https://iboard.ssi.com.vn/bang-gia/hose'
            self.mlist = internal.mlist(['HOSE'])
        elif exchange == 'HNX':
            self.url = 'https://iboard.ssi.com.vn/bang-gia/hnx'
            self.mlist = internal.mlist(['HNX'])
        else:
            raise ValueError('Currently monitor HOSE and HNX only')

        todate = dt.datetime.now().strftime('%Y-%m-%d')
        fromdate = bdate(todate,-22)
        self.avgVolume = pd.Series(index=self.mlist,dtype=object)
        for ticker in self.mlist:
            self.avgVolume.loc[ticker] = ta.hist(ticker,fromdate,todate)['total_volume'].mean()


    @__retry__
    @__sendMail__
    @__getHTML__
    def run(
        self,
        hide_window=True  # rất dễ lỗi khi hide_window = True
    ) -> pd.DataFrame:

        options = Options()
        if hide_window:
            options.headless = True

        driver = webdriver.Chrome(executable_path=self.PATH,options=options)
        wait = WebDriverWait(driver,60,ignored_exceptions=self.ignored_exceptions)
        driver.get(self.url)

        exec_time = dt.datetime.now()

        class_mapper = { # mostly for reference
            'Ticker': 'stockSymbol',
            'Ceil': 'ceiling',
            'Floor': 'floor',
            'RefPrice': 'refPrice',
            'BuyPrice3': 'best3Bid',
            'BuyVolume3': 'best3BidVol',
            'BuyPrice2': 'best2Bid',
            'BuyVolume2': 'best2BidVol',
            'BuyPrice1': 'best1Bid',
            'BuyVolume1': 'best1BidVol',
            'MatchPrice': 'matchedPrice',
            'MatchVolume': 'matchedVolume',
            'MatchChange': 'priceChange',
            'MatchChangePct': 'priceChangePercent',
            'SellPrice1': 'best1Offer',
            'SellVolume1': 'best1OfferVol',
            'SellPrice2': 'best2Offer',
            'SellVolume2': 'best2OfferVol',
            'SellPrice3': 'best3Offer',
            'SellVolume3': 'best3OfferVol',
            'TotalVolume': 'nmTotalTradedQty',
            'High': 'highest',
            'Low': 'lowest',
            'FrgBuy': 'buyForeignQtty',
            'FrgSell': 'sellForeignQtty',
            'RemainFrgRoom': 'remainForeignQtty',
        }

        tickerColumns = [
            'Ticker',
        ]
        priceColumns = [
            'Ceil',
            'Floor',
            'RefPrice',
            'BuyPrice3',
            'BuyPrice2',
            'BuyPrice1',
            'MatchPrice',
            'MatchChange',
            'SellPrice1',
            'SellPrice2',
            'SellPrice3',
            'High',
            'Low',
        ]
        volumeColumns = [
            'BuyVolume3',
            'BuyVolume2',
            'BuyVolume1',
            'MatchVolume',
            'SellVolume1',
            'SellVolume2',
            'SellVolume3',
            'TotalVolume',
            'FrgBuy',
            'FrgSell',
            'RemainFrgRoom',
        ]
        percentColumns = [
            'MatchChangePct',
        ]

        tickerElems = wait.until(EC.presence_of_all_elements_located((By.CLASS_NAME,'stockSymbol'))) # quét all mã CP
        tickers = [__formatTicker__(e.text) for e in tickerElems]
        table = pd.DataFrame(columns=['Time']+list(class_mapper.keys())[1:],index=tickers)
        funcs = []
        for col in table.columns[1:]: # bỏ cột Time
            if col in priceColumns:
                funcs.append(__formatPrice__)
            elif col in volumeColumns:
                funcs.append(__formatVolume__)
            elif col in percentColumns:
                funcs.append(__formatPct__)
            elif col in tickerColumns:
                funcs.append(__formatTicker__)
            else:
                raise ValueError(f'column {col} is yet classified')

        for ticker in table.index:
            t = dt.datetime.now()
            table.loc[ticker,'Time'] = t
            xpath = f'//tbody/*[@id="{ticker}"]/td'
            row = wait.until(EC.presence_of_all_elements_located((By.XPATH,xpath)))[1:] # bỏ cột Ticker (vì lấy rồi)
            raw_list = [e.text for e in row]
            converted_list = [a(b) for a,b in zip(funcs,raw_list)]
            table.loc[ticker,'Ceil':] = converted_list

        driver.quit()

        # save full list to pickle
        folder = exec_time.strftime('%Y.%m.%d')
        if not isdir(folder):
            os.mkdir(folder)
        table.to_pickle(join(dirname(__file__),'PriceBoardSnapshot',folder,f'{exec_time.strftime("%H.%M.%S")}.pickle'))

        # warning cho RMD
        mtable = table.reindex(self.mlist)
        mtable = mtable.loc[mtable['MatchPrice']==mtable['Floor']]
        sumWaitSell = mtable[['SellVolume1','SellVolume2','SellVolume3']].sum()
        FrgNetSell = mtable['FrgSell']-mtable['FrgBuy']
        flag1 = sumWaitSell >= 0.2*self.avgVolume
        warnings1 = pd.DataFrame('Giảm sàn, Dư bán hơn 20% KLTB',columns=['Message'],index=flag1.index[flag1])
        flag2 = FrgNetSell >= 0.2*self.avgVolume
        warnings2 = pd.DataFrame('Giảm sàn, NN bán hơn 20% KLTB',columns=['Message'],index=flag2.index[flag2])
        warnings = pd.concat([warnings1,warnings2])

        # Lưu file tạm để đọc ở lần quét sau (warning cho RMD)
        warnings.to_pickle(join(dirname(__file__),'TempFiles',f"{exec_time.strftime('%Y.%m.%d')}"))

        return warnings
